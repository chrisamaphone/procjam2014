fun manip s = 
let
   val parts = String.fields (fn c => c = #"'")
                 (String.concatWith " " 
                    (String.fields (fn c => c = #"_") s))
   fun capsify s =
      if s = "" 
         then "" 
      else str (Char.toUpper (String.sub (s, 0))) ^ String.extract (s, 1, NONE)

in
   String.concat (hd parts :: map capsify (tl parts))
end

%%

%term
  LCURLY
| RCURLY
| LBRACK
| RBRACK
| LET
| EQ
| IN
| DOT
| LAM
| BANG
| COMMA
| XID of CelfTrace.resource_var
| ID of string
| ONE
| SOLUTION
| COLON
| EOF

%nonterm
  tuple of CelfTrace.resource_var list
| consts of string list
| step of CelfTrace.step
| first of CelfTrace.resource_var list
| epsilon of CelfTrace.step list
| lams of string list
| solution of CelfTrace.clftrace

%pos unit
%start solution
%name Trace
%noshift EOF
%eop EOF
%verbose

%%

solution: SOLUTION COLON LAM lams tuple DOT LCURLY epsilon tuple RCURLY
({consts = lams, initial = tuple1, epsilon = epsilon, final = tuple2})

lams: ([])
      | BANG ID DOT LAM lams (manip ID::lams)

first:  LET LCURLY tuple RCURLY EQ XID IN (tuple)

tuple:  ONE ([])
      | XID ([XID])
      | ID ([])
      | LBRACK XID COMMA tuple RBRACK (XID::tuple)
      | LBRACK ID COMMA tuple RBRACK (tuple)

consts: ([])
      | BANG ID consts (manip ID::consts)

step: LET LCURLY tuple RCURLY EQ ID consts tuple IN
({rule = ID, consts = consts, inputs = tuple2, outputs = tuple1}) 

epsilon: ([])
      | step epsilon (step::epsilon)
