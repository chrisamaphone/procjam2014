open CLF

%%

%term
  LCURLY
| RCURLY
| LBRACK
| RBRACK
| LPAREN
| RPAREN
| LET
| EQ
| IN
| DOT
| LAM
| BANG
| AFF
| COMMA
| XID of CLF.resource_var
| ID of string
| ONE
| SOLUTION
| COLON
| EOF
| APP

%nonterm
  solution of exp
| pattern of pattern
| exp of exp
| atomic_exp of exp
| value of value
| values of value list
| mexp of mexp

%pos unit
%start solution
%name Trace
%noshift EOF
%eop EOF
%verbose

%%

solution: SOLUTION COLON exp (exp)

pattern: ONE (POne)
      | XID (PXid (Lin, XID))
      | AFF XID (PXid (Aff, XID))
      | BANG XID (PXid (Pers, XID))
      | BANG ID (PId ID)
      | LBRACK pattern COMMA pattern RBRACK (PPair (pattern1, pattern2))

exp: LAM pattern DOT exp (Lam (pattern, exp))
      | ID values (Id (ID, values)) 
      | XID values (Xid (XID, values)) 
      | LCURLY mexp RCURLY (Lax mexp)

values: ([])
      | value values (value :: values)

atomic_exp: XID (Xid (XID, [])) 
      | ID (Id (ID, [])) 
      | LPAREN exp RPAREN (exp)

value: ONE (One)
      | LBRACK value COMMA value RBRACK (Pair (value1, value2))
      | atomic_exp (Down (Lin, atomic_exp))
      | AFF atomic_exp (Down (Aff, atomic_exp))
      | BANG atomic_exp (Down (Pers, atomic_exp))

mexp: LET LCURLY pattern RCURLY EQ exp IN mexp (Let (pattern, exp, mexp))
      | value (In value)

(*
solution: SOLUTION COLON LAM lams outtuple DOT LCURLY epsilon intuple RCURLY
({consts = lams, initial = outtuple, epsilon = epsilon, final = intuple})

lams: ([])
      | BANG ID DOT LAM lams (manip ID::lams)

intuple: ONE ([])
      | XID ([XID])
      | AFF XID ([XID])
      | term ([])
      | LBRACK XID COMMA intuple RBRACK (XID::intuple)
      | LBRACK AFF XID COMMA intuple RBRACK (XID::intuple)
      | LBRACK term COMMA intuple RBRACK (intuple)

outtuple: ONE ([])
      | XID ([XID])
      | AFF XID ([XID])
      | BANG XID ([XID])
      | LBRACK XID COMMA outtuple RBRACK (XID::outtuple)
      | LBRACK AFF XID COMMA outtuple RBRACK (XID::outtuple)
      | LBRACK BANG XID COMMA outtuple RBRACK (XID::outtuple)

consts: ([])
      | BANG ID consts (manip ID::consts)

step: LET LCURLY outtuple RCURLY EQ ID consts intuple IN
({rule = ID, consts = consts, inputs = intuple, outputs = outtuple}) 

epsilon: ([])
      | step epsilon (step::epsilon)

term: ID terms (())

terms: (())
      | BANG ID terms (())
      | BANG LPAREN term RPAREN terms (())
*)
