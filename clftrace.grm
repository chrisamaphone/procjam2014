fun manip s = 
let
   val parts = String.fields (fn c => c = #"'")
                 (String.concatWith " " 
                    (String.fields (fn c => c = #"_") s))
   fun capsify s =
      if s = "" 
         then "" 
      else str (Char.toUpper (String.sub (s, 0))) ^ String.extract (s, 1, NONE)

   val () = 
      case parts of 
         [] => raise Fail "Manipulating a id that was apparently just \"'\""   
       | _ => ()
in
   String.concat (hd parts :: map capsify (tl parts))
end

%%

%term
  LCURLY
| RCURLY
| LBRACK
| RBRACK
| LPAREN
| RPAREN
| LET
| EQ
| IN
| DOT
| LAM
| BANG
| AFF
| COMMA
| XID of CelfTrace.resource_var
| ID of string
| ONE
| SOLUTION
| COLON
| EOF

%nonterm
  tuple of CelfTrace.resource_var list
| consts of string list
| step of CelfTrace.step
| epsilon of CelfTrace.step list
| lams of string list
| solution of CelfTrace.clftrace
| term of unit
| terms of unit

%pos unit
%start solution
%name Trace
%noshift EOF
%eop EOF
%verbose

%%

solution: SOLUTION COLON LAM lams tuple DOT LCURLY epsilon tuple RCURLY
({consts = lams, initial = tuple1, epsilon = epsilon, final = tuple2})

lams: ([])
      | BANG ID DOT LAM lams (manip ID::lams)

tuple:  ONE ([])
      | XID ([XID])
      | AFF XID ([XID])
      | term ([])
      | LBRACK XID COMMA tuple RBRACK (XID::tuple)
      | LBRACK AFF XID COMMA tuple RBRACK (XID::tuple)
      | LBRACK term COMMA tuple RBRACK (tuple)

consts: ([])
      | BANG ID consts (manip ID::consts)

step: LET LCURLY tuple RCURLY EQ ID consts tuple IN
({rule = ID, consts = consts, inputs = tuple2, outputs = tuple1}) 

epsilon: ([])
      | step epsilon (step::epsilon)

term: ID terms (())

terms: (())
      | BANG ID terms (())
      | BANG LPAREN term RPAREN terms (())
